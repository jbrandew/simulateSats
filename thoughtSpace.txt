Hello :) 

Working on the project. What to do? 
Having a graphical bug with something. 
Thought: decrease radius and maybe we can work with smaller numbers. 

as expected, that did nothing. Now, make the sim input much simpler and see whats wrong 


aight uhhh what are we doing 
walker star constellation plotter works 
Now what? 

1. transfer newTestSpace.py data to a usable package 
2. resume implementation. What does this mean? I will pull up and see my notes for
the previous research paper and go from there afterwards 

#resolution of envelope detector -> BW of it kinda... yee...
anyways 

trying to organize functionality 

rotate3d 
deepCopy 
plot3d 
generateWalkerStar 
plotWalkerStar 

so lets have a 
"myMath" 
"myPlots" 
"myRandom" 

to designate each package we are using 


Problem: 
in each plane, the plotter repeats the coordinates of two points
probably, problem = whe 

Problem: 
not able to graph cone correctly to graphically verify results

Solution: 
simplify by:  

1. parametrically describing cone with a specified angle of opening 
-ez & done 
2. rotating by the angle of the vector 
-ez
3. shifting all points from the initial set to the new one 
-ez 

Types of results to put in paper: 
current class structure and packages 
graphic of Walker Star 
graphic of connections from base station to in view satellites...
table of results for min elevation angle 

Thought: 
our main seems pretty disorganized. 
i dont like how we are calculating the numberInView in main. That should be a base
station's job. So i dont think we need a bigger overseer, at least not yet. 

btw, difference between their results and ours for first part of verification could be
from going the other direction when looking at phase difference


thought: 
total length of orbit = (6371 + 1000) * 2 * Pi 
distBetween two = around that / 19 

the 20 disconnected segments just means that we have 20 planes that arent connected 

question: 
should linking to the base station be in the connect2ISL? 
or should that type of function focus on inter satellite connections, and 
then we have a different function that connects to all satellites within field of view 
	-i like this 


thought: 
not sure how to plot inter satellite links and satellite to base station links 
have "links" variable 


what is the "spiral" referenece topology? 
4 ISLs per sat. 
I think its 4 ISL because you maintain connection with your the ISLs in your plane, 
and then additionally the 2 ISLs in adjacent planes for same phase 
-so connect to the next plane and previous plane with same satellite position 

thought: 
super confused as to why its connecting to a seemingly random other satellite when jumping
some of the time.

possibilities: 
not iterating correctly 
not instantiating satellites in the correct order
...

is this even worth doing? spend 5 minutes and then move to next concept
-give up, use basic one. realize though that the satellite data structure 
may not be properly sorted in lat/long...maybe... 

Introduce satellite failures: 
1000 random sets of n satellite failures (so inf = adj matrix row and col) 
for each of these sets, 5000 sets of surviving used...


Next idea: 
max throughput/overall transmission
just a bit of work into it, then study for other things

so need to: use utility functions with dynamic routing, a bit. 


each sat = MG1 Q from ground station

different approaches for final stage: 
-time steps with location of each and frame processing 
-make each satellite an markov receival from ground plane, with each 
having a random destination (being another satellite). then, simulate overall throughput of different topology schemes 
-i like this 

breaking this into steps. Do we establish the sampling of each being an markov queue first,
or do we work with moving in location with space? 

-markov queue first, then moving in location 
1. establish base case with exponential receiver 
-done, have functions for it 
2. implement base case into receival for stationary satellites
-now what? need to use this base case implementation for general receival. Is there a way 
to do that without using time frames and multiprocessing? 
3. maybe move into moving components 

Difficult to process/implement this. 
1. first approach i can come up with: have each satellite be a separate process. let there be a "packet" object with destination, current processiintme, hell no too much 

2. second approach: 
a. have # of exponential arrival processes = # satellites
b. for each process, generate inter arrival scheme
c. for each arrival, create a destination satellite (we already have the "from" satellite)
d. plot each path sending in pseudo real time, so slowed down alot, but sent 
	(maybe have # of packets on line => diff color 

3. refined second approach
a. have # of overall arrivals = sum of all processes. randomly choose source and end. 
b. for each source and end, get the path as well as the links used and the time frame each link was used within
c. 

Phases: 
1. given adjacency matrix and source and end, output the path as list and end amount of time
2. now that we have the path for each start and end, now a set of paths from interarrivals
3. from this set of paths, what do we want to do? could: 

-compare usage of base station links to inter satellite links 
-could plot: 
	-average satellite link usage time vs rate 
	-average base station - satellite link usage time vs rate 
	
Process: 
generate interarrival times for each packet (dont need this) 

get start and end for each packet 
get associated path and overall transmit time 
for each path, for each link, add the prop delay to each end of the link to model general overhead 

then, plot overhead for average satellite and average base station 
then, plot overhead of satellite vs proximity to base station (should go up) 


slow down packet transmission by alot. for each request, there wil


random thought: should the processing at each satellite be exponential as well? what really "processing" is there to do? are we modeling the routing computation as this "processing?" 


okay, end project results to put up: 
diagram of class structure 
data pipeline 
figure of just walker delta points
figure of base stations with 2 ISL topology 
figure of adjunct topology 

figure of comparison of results for avg connection time 
figure of use time vs proximity to base stations 

discuss framework for expansion 


need a bit more results, just a bit. 
how did we index the pseudo cap? (in terms of planes and sub parts) 


originally, sats was: 
num plane x satSubInd 

then, after ravel, it was 

row1 data, row2 data, row3 data 


With the drastic reduction in price for launches of all types of satellites, a more in depth analysis of optimal routing, constellation & topology selection is needed. Most existing simulation frameworks do not consider multi-satellite coordination, stochastic environments, or dynamic selection of routing paths. 

Approaches to satellite topology must rightfully be approached in a much more different way when compared to ground networks, because of different conditions regarding speed of changes in topology, noisy conditions, and vulnerabilities to interference. 

This project implemented a majority of the paper [], creating a modular framework that allows for easy expansion in the future, to better generate data for selection of network parameters. In addition, some analysis in a Monte carlo simulated player usage was done to show how proximity to a base station affects a satellites usage in time. 

For tackling this, a very sequential data pipeline was needed, shown in figure 1. The config file allows for a choices involving, number of each satellite, base station, and general initialization. Each other step uses this data. 

In the class structure, purple has yet to be implmented, as we have yet to start stochasticness from the user, and only worked with PLEO here. 


I now understand why im getting funky results for the spiral topology and those in general.
Its because beforehand i was operating under the assumption that the highest index in the plane subset was the highest altitude. This is incorrect because of the phasing rotation. 
Instead, work with latitude and longitude. If we are outside the 70 range, dont connect. 
If the satellite we would connect to is outside the 70 range, dont connect to it. 

thats not the only problem. The other one is the modulus operation we were doing. 

so, it connects to the correct next plane, but not the correct satellite index after doing a full revolution 
-so offset by a certain in plane index when you do a full rev. 


just getting used to this new keyboard sigh

where were we? just implementing the spiral topology thats fully connected 

so, whats the problem? something to do with how we iterate through the satellite planes. 

should we instead iterate through spirals instead iterating through planes? could have reference start with the 

how many satellites in a spiral? determined by the phasing constraint and the restriction on latitdues where the ISL connections are allowed 

how do we iterate through a full spiral? must iterate past just one plane... 
there should be # of spirals = # of planes 

so approach should still be iterate thorugh 

confused: 
the first loop with planeIndex iterates through # of planes 
the second loop with samllSatInd 

so wait, how does the second index of the satellite data structure seem to be more of the plane than the other... 

nah it checks out. it just looks that way because of the requirement for the latitude thing. 

so, first loop is the plane index, which is fine. There should be one spiral per plane. 


The second loop should iterate through many more. there is a specific offset within one plane for how many satellites ahead you should index when looping back around. what is that equal to? 
its equal to the number of planes*phasing parameter/ (360/ # of satellites per plane) 

okay, thats the offset. How long should a spiral be though? the # of revolutions should be equal to the 180 / (phasing parameter * number of planes) 

how many spirals should there be? 


uhhh what are we doing? 
end goal: structure in which to implement reinforcement algorithm for optimizing both (I think) topology formation and packet routing policy 
current general step: creating simulation structure for allowing this algorithm to run. 
current specific step: implementing topologies that i could use in the future to test out different routing policies. also, helps in general with observing structure. 

thoughts: 
i dont like the location of my current project, located in final project when im already done. with the project. 
i dont particularly like some aspects of the project structure, so ill examine that as well. 
need to move all essentials to different folder. 
id like to have this on github as well

Okay, we are back. 
ending the excursion into cliques for now. 

What are we doing? 
reviewing what we are stuck on, and then: 
modifying djikstras approach to use previously constructed graph 

what was this originally doing? 
taking a random set of n satellites
computing x paths and seeing how many of those paths would intersect the group of n satellites (which we are saying has failed) 

currently, we are using djikstras algorithm every time we seek a new path in the graph with n nodes failing. 
instead, could use an optimized version in which we use the previous routing table, as its in the same graph 

thought: could use this in practice, if topology is roughly the same/see how it changes over time (preventing us from having to compute djikstras again and again) 

so, what is this problem formalized as? 
if we have a graph g with nodes n and edges e, what is an efficient way to compute x number of paths between x pairs of nodes within the graph? 

will use djikstras, but use the routing table from before in construction of ours. 

ideas: 
basic: have an overall routing table. after you compute all your shortest paths, put those in the table. so if you get called again, you can refer back to it. 
advanced: examine relationship between routing table of each other node...

used floyd warshall with subset, it worked. 
now, just need to use it within the simulation sphere 

what are we doing? 
seeing what the difference in data type is between the floyd call that worked vs the one that didnt 



uhhhhhhhhhhhhhhhhhhhhhhhhhh what are we doing 
so the one approach worked very poorly, so we need to just...look at the notes from last meeting and examine if there is anything we can work on

action items: 

follow these action items. (simulation, routing, topology, then ways for potential routing) 
-routing or topology, RL is a good approach
-links you can form and user demands -> stimuli for RL algo. 

could spread out users -> each need 10b/s, evaluate how well they satisfy stuff 
-should be nonuniform or uniform traffic demand
-could be uniform and then sudden hotspot -> how does the system respond/change its connectivity 

-priority/size/requried BW of packets...maybe...not really mut. ex. 
-modeling overhead of switching ISLs -> one of the standards has reconnection time for satelliets (paramaterize over) 
	-compare answers of toplogy for different reconnection times 
	

a. modify simulation enviroment to include: 
-attenuation effects of ISLs that cross the 100km threshold in atmosphere 
-put a cost to adding an ISL. Might make higher orbit GEOs more worth it, as they require less connections, as their field of view is wider 
-impelement facets from SDA standards, which include: 
https://www.sda.mil/wp-content/uploads/2020/08/9100-0001-01-OISL-Standard.pdf
https://www.sda.mil/wp-content/uploads/2022/04/SDA-OCT-Standard-v3.0.pdf

b. run throughput caluclations and compare: 
-greedy case of connecting to nearest satellite (s) in the various topologies vs the case of using our algorithm that we develop 

c. look into research with the alyria tool for topology management 

d. compare output of using optical connections vs RF connections 
-optical: specific area, high data rate 
-RF: large area, low data rate (phased array antenna) 

e. implement the distributed case of communication
-so, each satellite doesnt know the whole topology (what connections each other one makes, etc.)
-"link discovery packets" are used, advertising distances/connections 
-this could be better than Alyria, which assumes centralized.

f. exploring this notion of maximaly spread out choice of edges/links 

Questions: 
on e, the general process is:  

init: 
-each sat is connected to n nearest satellites 

repeat step: 
-advertise what satellites you are connected to to the satellites you are connected to and distances to nearby satellites 
-based on a policy and what nearby satellites say to you, change who you are connected to next 


questions: 
-each satellite is changing who they are connected to based on information from other satellites, which in the next time step may be false (as satellites may have changed their connections)
-BF algorithm worked with finding shortest path between one node and all other nodes via a distributed manner, but that was in a static graph (ISLs didnt change, nor did distances between satellites). So it doesnt seem super applicable to this situation 
	-like, the "reliability/accuracy" of channel/topology state information is dependent on 	
	how far satellites are from each other 
	
	-fish eye routing: (less frequent link updates on others away) 
	-geographic routing/groupign those in a certain area 
	-toplogy construction vs routing problem (which one im trying to solve) 
	-"geneated algorithm.." with toplogy construction
	-notion of "age of information".... (considered with RL, why its good) 
	-RL could pick up on more complex relationships 
	
-what if there is some general information known by each satellite?
	-for example, it seems plausible that in a walker delta constellation, every satellite 
	would easily know where every other satellite is. however, the packet processing delay/
	how many packets are already queued up could be seen as a stochastic process
	
	-probably reliable to assume we know yea...notice failures 
	 
-are there algorithms for shortest path in a changing graph? 
-should there be a notion of "recomputing" only when the adjacency matrix we computed when establishing our last policy differs by a certain threshold from the current state/adj matrix? 


how do me measure throughput/performance of a certain policy/compared to baseline? 
-in a static case without moving, evaluate the average latency of a packet (so between a pair of nodes). 
-repeat that many times.... 

-if im constrainted on uplink or crosslink capacity -> how does that change components/policy 

what are we doing now? we are using the standards document to incorporate various limitations. 
then, examine throughput results for latency etc. along the parametirization

actually, first review class structure 

what are we doing? need to calm down. 
changing the location of the simulator for seeing num satellites in view of base station. 

aight. i need to calm down, and think of how to best approach this. figured it out, its good now :D 

what next? modifying floyd warshall thingy. 
first, test the modified version 
uhhh i think its about good. kinda good. something wrong teehee.

move on to incorporating standards for more accurate analysis. 
1. wavelength used: not sure
2. polarization type: not sure 
3. OISL switchable...not sure. i think that means that we have bidirectional ISLs 
4. limiting min and max flux at a certain altitude... 
-is this in the context of isotropic antennas? or, should i examine this in the context of directional antennas? 
-so, waves are transmitted out uniformly in all directions. To get the power, do i just use friszs, or something else? 
5. link margin. 3db...? added power strength beyond the normal amount that you use to ensure relaible comms. 
-so, would need to start working with effective BER/SNR for a certain communication scheme used
-wouldnt need to necessarily have simulation at the modulation level, but could have stochastic error analysis  
6. Modulation type: on off keying, NRZ 
7. LDPC FEC (could just use this with overhead budget and increase in SNR) 
-this increases SNR 
8. BER after FEC (relating SNR with decision stat/maybe multipath...?)
-so, this would relate to the SNR of our implementation 
9. adaptive coding and modulation...? so different vars change with conditions, but its not really deterministic in what it means..
-not sure if i would implement this...or how i would even do that
-is this outside the scope of this project? 
10. OISL term to term timing accuracy  10 ns (threshold) -> 1 ns (objective) 
-what even is timing accuracy? i think it deals with synchronization that allows better data transmit, sat tracking, handover of users, 
-im not really sure exactly what this sychronization means...maybe like real world clock time...or something 
-useful in schemes like TDMA where each user is assigned a time slot 
-
11. aoeuea

OISL ranging accuracy: estimating location of other satellites 
Range rate accuracy: estimating speed of other satellites 
Point ahead capability: idk, its TBD 
aquisition time: not sure what this exactly means. its like 100s, so i dont think it deals with sat to sat. it might though, as an orbit for a LEO is ~90-120 min. 

Questions/Plans concerning implementation: 
Wavelength bands parameters: this goes over frequency slots a certain user can have 
-how would i implement this? should this be a parameter to optimize over?
-and then, i guess each user gets a slot, and the level of interference with others would possibly be affected 
by their own frequency bands in the event of misalignment etc. 

Polarization Type: 
-left hand circular polarization. How would i use this? 
-if all are LHCP, maybe dont do anything anyways...
-kind of confused on the actual wave traveling types...

OISL switchable pairing: 
-bidirectional links

Proposed max flux:
-so, the flux radiated outwards. Is this total, or in the non-directional area for a non-isotropic antenna? 
-should this be another parameter to optimize over in tangent with the hardware constraints in terms of output
power? 

Link margin: 
-above 3dB SNR for the given communication scheme that already meets the required BER 
-so, use this with the required power output 

Modulation format: 
-OOK, NRZ
-should we get down to this level of implementation? 

Coding: 
-LDPC. Just look at given gains in SNR based on this, I believe 

BER: 
-10^-6, 10^-9, (threshold vs wanted) 
-examining the end result...

Link Training: 
-adaptively changing parameters of an ISL as response to channel to max good stuff
-to use this, it would need time frame simulation, and examining channel stochastically 

Framing: 
-ARQ stuff
-do i need packet level simms

Link Management: 
-kind of in tandem with link training
-"negotiation policy," sync data, etc. 

OISL term to term & timestamp acc.: 
-how accurate the attachment of "when a message was sent" is 

OISL ranging acc and range rate acc.: 
-how accurate estimate of other sats velocity and location is 

Acq time:
-how long to connect to sat. 

Sun excl. angle: 
-min angle between sun and line of sight to avoid attempted comms

Terminal orbital regime: 
-750 to 1250 

Thoughts: 
-so, i could make a communication scheme with each of these and actually implement the transmits at the packet 
level. Could do it on a multiprocessed system where each process is a satellite...and you have the main
monitor of all processes 
-or maybe i just dont. 
-alot of these parameters (LDPC, modulation type, framing, link management, polarization type, etc.) deal
with implementation details. Should I: simulate the given communication scheme and examine the output BER/SNR
for a parameterized noise system? Or should I: have a dictionary of different comm. setups, each with their own
BER/SNR for a given setup from papers. Then, modify the calulations based on this environment instead? So, pre
calculate the effect these implementation details have on the overall BER, and then use that BER with some things
held constant, like max flux. 
-some of these parameters are kind of outside comm. implementation, and deal more with environment analysis. Like: 
sun exclusion angle, acq time, orbital regime, etc. 
-question: they have ranging acc and range rate acc. Does a satellite estimate other satellite's movement params 
then, or are they communicated? 

This is my categorization of different parameters in the SDA documentation: 

Different levels of simulation: 
-packet level: each user on the earth has a packet. deals with overall handshaking, and more of the TCP stack
-signal level: we ignore packet details. we work with complete signal implementation 
(FEC, mod. type, pol. type, mod type., antenna radiation pattern, comm. directionality of antenna/sat, OFDM ) 
and actually measure and record the BER for a reciever for a variety of different signal implementations
-satellite coordination level: we ignore all signal implementation details. we work at the level of: given a 
satellite at one position, use a specific BER with respect to a satellite at x distance away. this will still 
implement details such as sun exclusion angle, acq time. 

The end goal is yes, to simulate optimal policy to:
minimize latency for a standardized max power output (and probably some other restrictive parameters that im 
forgetting). 

However, what level of simulation should this entail? My understanding of the situation is that if 
I simulate at the packet level, ill also have to implement all at signal level & sat. coordination level, etc. 

Is this a logical framework for how to approach this problem?  

what are we thinking? regardless, we need to incorporate some kind of time frame analysis into the simulation 
framework, and then implement various policies with respect to changing topology. So, i think we can work with a
basic case for this and go from there. 

Okay. Work with the case of just 2ISL IPO. So the only ISLs that will change are the base station ones 

checkpoint: 
maybe work with animation for time frame. so in matplotlib, can use animation tool. I asked cgpt it before, 
just refer to that. facing some issues with wsl ubuntu plotting here...

okay: 
animations are easy
just need to use the example code for 3d updates
now....what do we do 
need to convert current code to changing time frame 

thoughts: 
i want to have animation stuff in myPlots
i want to have math computation/object stuff in classes 

how do i separate those two? 

if i have the animation code within myPlots...then 

i should use object/state concepts rather than opting for direct calculation each time 
so, have a velocity component in each satellite as well 
no velocity, as im not sure how...

need:
current position 
time change 

to output: 
next position 


i should be constructing this in a way that uses the "state" of the constellation, while turning on an option that displays the data 
then, the animate movement 

what is our current class structure: 

simulator
manager (has objects) 
plot funcs 
main 

so: 
simulator: controller 
manager: model
plot funcs: view 

i will need to change locations of some functions to best reflect this architecture 

i need to adapt code to the helix plot model 

so: 
first clear axes
then call multiplot function with ax given 
then display outside of the func animation call 


get next position is not working because we are not giving it the tangential velocity for each satellite
each satellites tangential velocity is the same 


next step: 
just take the code for calculate new position with the angle diff.....and the normal vector
then combine functions to give the modified new position function, see it used in animation data.... 
yea...later on create policy for reconnection, maybe do throughput analysis over time 

okay, so time frame structure is done. next steps. could either: 
-implement policies for what to connect to/changing topology
-modify simulation environment to include additional features (look at previous ranking)  

Yea, start with sun exclusion angle. Then, work into changing topology policies.

So, sun exclusion angle: 
min angle between satellite connection and sun that we need to have to protect satellites in optical comms
-can also kind of be used for RF comms as well 
 
Thought: 
want to place restriction on any ISL formation 
need to modify structure for better compactness 

testing: 
current in view array 
[(12, 11), (10, 9)]

after: 
matches

Next: 
change connection method to account for solar thingy 

Where should sun location be stored? computation -> manager 
Thought: where should we be passing in location of sun....

So, sunExclusionAngle done. What next? Reconnection policy...

Needed: 
policy for checking if a satellite connection is still valid over period of time...
like, between frames, it doesnt check if connections are valid. 

Also needed: 
get server running setup, and then use x11 forwarding (per chatgpt) to have the displays still shown on this computer 


What topologies do we have?
-spiral
-every nth connection spiral  
-zig zag
-ladder 

So, what do we do? 
1. Modify the existing process to check if there are any connections that violate the polar constraint. 
-actually, modify entire approach to ISL. always connect, then only display/use if it doesnt violate it the constraint
-after asking them question about ISLs for planes, will see about implementation method  
2. Examine throughput analysis for each with time varying....
3. 

Thought: 
-not sure how to best analyze ISLs
-thought: dont use polar region restriction in forming the ISLs. only check the polar region restriction once we are examining throughput or we are graphing the data. 

note: 
currently simulate transmits doesnt work as intended because ISLs above polar region are used, even with IPO connections. So wait to see what advisor says about optimal policy. 

Next: 
work with consistent BER, and get avg throughput rate of packets 
...maybe work with SNR 

Variables to consider for calculating SNR of a connection: 
-path loss
-received power 
-noise
-BER
basically, just using friszs transmission theroem 

idea: 
-record set of metadata for each packet transmitted
-then, at the end of the simulation, calculate throughput...
-nah, then wed have to store alot of states for each set...unless we wanted to sim. in blocks 


Next actually: 
implement policy for connecting to nearest 4 players for each player 
at each time step, reconnect to nearest 4 
compare stuff at that time 

thought: 
we are at times getting closer to a situation that involves having a one-directional link....

problem: need to impleemnt closest points method for...objects...not just numbers yay i did it 
and its not super duper computationally intense....

what next? figure out gnu radio stuff....

okay, so how to do that? i need to get a base case going for 

not doing gnu radio stuff anymore. New thought process:
-so we are trying to test the effectiveness of a topology/network when we have a specific power allocation & choice of topology. 
-how do we test this? base case: 

-given a topology
-with random power allocation 
-have a # of users randomly spread across the globe, all try to transmit data 

different methods for simulating that: 
1. processing time for batch of data. given a # of transmits, look at how long it takes for
all data to be processed if each satellite has a given rate of processing and there exists a 
certain capacity for each ISL based on the power allocation. (for now, since we arent sure 
about how power/BW allocation affects the capacity, lets just assume a constant max rate) 

2. reconciling the time dependent processes of satellites moving, users transmitting data, 
packets being processed at terminals, packets being sent. So could have different processes tracking different sets of data: 
Process a: tracking and updating satellite location 
Process b: pre determining the message launch time for each user/location, and then communicating that with others 
Process c: tracking when satellites process data. based on each sats comp power and queue
length, send out data to a diff sat. 

3. Or, destroy pure time dependency: 
step 1. Create a set of messages to be sent with time tags/locations for each 
step 2. With a given time resolution and time frame, look at if each packet is 
processed/needs to transfer.
step 3. Within this, keep track of how many packets are processed within the time frame we have 

I think we should detach real world time dependency from simulation/processing time dependency entirely.
Have a time set. Have a time resolution.
Perform initial config, and: 
1. get initial positions of satellites
2. get a # of packets information -> time stamps for transmit, location from which packet is sent
 
And then, at each time step:
1. Change locations of satellites (if its too small relatively, might not do this. Might just repeat the 
trial and  have randomly spaced locations/intervals) 
2. Check each packet to see if the event they currently have is done occurring (existence, transmit, processing, etc.)
-existence: calculate shortest path (maybe in the future revise this to have shortest path take capacity into account)
-transmit: message will be in optical transmit for a certain length of time (this is based on the initial location) 
-processing: message will be processed from poisson process at each interrim location  
3. Once a packet has reached the end destination it stores info like end time, # hops, etc. 
4. Then, once all packets are processed compute relevant statistics 


Packet data type: 
phase: [dormant, in transmit, in process, in queue for transmit, finished] 
-amount of time in dormant determined by scheduled send
-amount of time in transmit determined by distance between satellites
-amount of time in process determined by process rate of satellites
-amount of time in queue for transmit determined by respective capacity of link 
triggeredEvent

What am i thinking about? 
the idea of how im going about processing events is difficult. Do i iterate through packets, players, what...?

if i iterate through packets: 

for each packet, checkForEvent. 

check for event for servers. 
for each server, simulate "numPackets processed" given amount of time (from time frame) 
then, assign that number of packets the "processed" event and remove them from queue
(this works between time frames from markov property) 

then, check for event for packets 
depending on phase, checkForEvent means diff behavior. 
If packet was in dormant: if time > scheduled wake up, then return needTransmit, get assigned path 
and go into in transmit mode. 
If packet was in transmit: if time > scheduled transmit, then add to corresponding satellite 
If packet was in process: if told by satellite/server that its processed, enter in transmit  


Question: 
what actually is capacity? its how many packets we can transmit over noisy channel with arb. low error. 
So, it deals with how fast we can send packets after processing 

Random thought: 
updates to satellite position and current queue states of satellites/servers would possibly make the optimal routing table 
out date, even to the extreme case of making some links non valid when they are considered valid. Kind of need a hyperparameter
with respect to rate of updating the routing table with respect to changing conditions. 
Additionally: 
within the update state process, there are certain components i could parallelize (checking state change, updating position, etc.) 

Random thought: 
need to make this as basic of a case as possible. So, compute all paths initially, only based on distance. Can compute paths
later with adaptable table, etc. 

check point: 
need to look at what order to handle events in and continue implementation 

Hello. Today is 2/18. I am now beginning work on some research stuff. I'm trying to calm down and proceed. Waht am i doing? 
In the meeting, I suggested: 
-an event tree where different events have a priority in being processed. At each time step, I see if i can add and then add the respective events. 
he suggested: 
-an almost continuous event tree, where some events are periodically added to the tree based on their respective resolutions. Then, some events, like packets being sent, trigger a chain. So each event being processed creates a different event with a different time stamp. Events are always ordered with respect to the time value. 

Im going to draw it out to discuss the event stack. 


what are we doing? trying to figure out what i was doing before....
i was testing for the most basic case, single packet transmission event sequence 


seems like alot of the use cases is...possibly working, but sometimes i get the event where i cant find a path between nodes.

so, need to establish
1. what could be wrong
2. how i should approach solving this :) 

1: 
djikstra implementation is incorrect
topology is not correctly set up 
usage of start and end locations is incorrectly used somehow....

2: 
try different topologies and different djikstra implementations. 
compute average latency scenario, and see if its finite. 

also, look at how exactly you are getting a single value to begin with


need to connect base stations probably...
what am i confused about..?

how satellites are getting connected to a bunch of other satellites in these two function calls...

what am i frustrated by?
every satellite and base station is connected to 44 others 
this feels impossible since the actual function is only called 36*2 = 2 times 

what am i confused by?
getting more than 2 links for each satellite, when i should only be getting the base stations connecting to those in view

seems like the correction is correct, so getting xyz of links may be wrong 

nevermind, it was correct, just how i was debugging was wrong

problem: 
the simulated transmission will be inf for the polar regions that dont even have the 2 isl thing 

what are we doing/what are we confused about? 
was confused as to why only had 2 links for each...

actually, its fine that we have 2 links for each. there is just something wrong about how we are plotting. 
also, confused as to why we are getting 3*links for xyz 
thats just the max size. its fine :) 

grep -rn is such a nice command for finding instances of code thats used 


aight, it feels like we fixed alot of things wrong. 
now what do we do 0_o 
the actual work lol

uhhh 
right 
the chained simulation 

current problems: 
-something wrong with chained simulation
-might not be taking care of case with getting the same sat for start and end...
-packetArriveTimes not saving correctly
-in general, transmit time is wrong, might be calculating prop delay incorrectly 

current problem: 
-only packet ind 99 is currently working/saving transmit data 
-found the problem 

next: change each step to appending to the dictionary 





data from chained simulation: 
(Pdb) hold
array([ 2.80285116,  7.79804571,  0.89046214,  6.35594686,  5.38951575,
        3.00952569,  1.3636941 ,  5.14487082,  3.17009137,  8.56859301,
        1.21703844,  4.86472933,  7.68289497,  2.03718684,  5.4306661 ,
        7.28809461,  7.91055246,  4.66839381,  8.87175644,  2.49912488,
        1.47666982,  1.23696718,  3.50524599,  1.71757178,  4.48352852,
        6.01140213,  0.22738539,  4.00082775,  9.52357383, 10.05908251,
        1.89591938,  2.86962536,  5.92044754,  6.01056003,  9.00850085,
        7.67314721,  5.09524875,  4.07511049,  0.80271968,  8.32031818,
        6.03895279,  4.90350598,  2.76238535,  0.17943794,  3.16207319,
        2.88183919,  6.69344394,  9.19686221,  9.28444732,  4.79591493,
        0.45785681,  2.22904452,  6.07178185,  9.81240788,  8.22766517,
        5.9400777 ,  3.70641136,  8.68106941,  8.32285854,  9.8583144 ,
        3.41107443,  0.68637016,  4.61507499,  4.43108279, 10.02516587,
        3.01008192,  5.55710303,  9.67023598,  1.158667  ,  2.12655334,
        3.92592175,  4.95075859,  0.49410206,  8.00237623,  4.87870434,
        9.00738291,  1.17970325,  5.89226674,  7.80433027,  4.58812001,
        3.07568422,  5.43577001,  5.67761362,  5.53649327,  9.15575667,
        9.74581276, 10.05873836,  3.1128527 ,  9.49708654,  8.17644883,
        6.92431029,  4.25399974,  6.62295377,  8.78450463,  1.88593599,
        2.3648051 ,  6.77564975,  8.44378254,  4.4436374 ,  9.52300191])
(Pdb)
avg: 5.3 

data from normal transmission simulation: 
.062 

So, probably something different in how we calculate path time differences in each. How to troubleshoot? 
-when i calculate the path for packet to be sent, also calculate the path and see if it matches with the previous....
-...compare summmmmmmmmmmmmmmmmmmmm rate 
-wait i think i got it. i think its cause i was just returning time of occurence, not difference in time! 

new one:
avg of normal data transmit: 
.0582 

avg of other transmit: 
.0946 

possible reasons: 
additionally have to go from ground to satellite -> 2 more stops that could be further. 
the two sets of paths/locations are generated independently 

the best reason: 
pseudo uniformly generating across globe vs across satellites is much different in terms of avg path length. 
satellites are much more clustered in some areas than others, compared to the pseudo uniform generation across the globe

also would be cool to mention difficulty of uniform globe point generation (concentrated circles) 
-idea: could space out circles enough within resolution proportional to their area/density....
good job :D 

what next? 
work on uhh.....
packet collision throughput analysis 
might need to work on server stuff for actual analysis 

avg for chained simulation of 1000 packets sent at same time: 
.0932 
same as before obviously, because we havent handled collision events/waiting at queue :)









 



